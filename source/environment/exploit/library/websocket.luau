local Net: table = require("@lune/net")
local Task: table = require("@lune/task")
local Rbxscriptsignal: table = require("@datatype/rbxscriptsignal")
local Url: table = require("@dependency/url")
local Manager: table = require("@env/manager")
local WebSocket: table = Manager.create("WebSocket")

local ParseUrl: any = Url.parse

WebSocket:define("connect", function(Url: string)
  WebSocket:checktype(1, Url, "string")
  
  local Scheme: string = ParseUrl(Url).scheme
  local isSchemeValid: boolean = (Scheme == "wss" or Scheme == "ws")
  assert(isSchemeValid, "WebSocket.connect: expected argument #1 (expected scheme to be wss, ws)")
  
  local Status: boolean, Client: ws = pcall(Net.ws.connect, Url)
  assert(Status, "WebSocket.connect: refused to establish connection")
  
  local IsRunning: boolean = true
  local OnMessage: userdata, C1: table = Rbxscriptsignal.Signal()
  local OnClose: userdata, C2: table = Rbxscriptsignal.Signal()
  
  Task.spawn(function(): nil
    while IsRunning do
      local Message: string = Client:next()
      if Message == nil then
        IsRunning = false
        C2.CallAll()
        return
      end
      
      C1.CallAll(Message)
    end
  end)

  return {
    Send = function(Message: string): nil
      local Status: boolean = pcall(Client.send, Client, Message)
      if not Status then
        IsRunning = false
      end
      assert(Status, "WebSocket.connect: failed to send message through websocket")
    end,
    Close = function(): nil
      IsRunning = false
      local Status: boolean = pcall(C2.CallAll)
      assert(Status, "WebSocket.connect: failed to stop websocket connection")
    end,
    OnMessage = OnMessage,
    OnClose = OnClose
  }
end)

return WebSocket.export() :: table