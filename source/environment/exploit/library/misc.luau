local Net: table = require("@lune/net")
local Roblox: table = require("@lune/roblox")
local Serde: table = require("@lune/serde")
local Url: table = require("@dependency/url")
local Default: table = require("@roblox/default")
local Internal: table = require("@env/internal")
local FS: table = require("@rlibrary/filesystem")
local Manager: table = require("@env/manager")
local Misc: table = Manager.create()
local Http: table = Misc:namespace("http")

local LastSaved: string = ""
local AllowedMethods: table = {
  GET = true,
  HEAD = true,
  POST = true,
  PUT = true,
  DELETE = true,
  OPTIONS = true,
  PATCH = true
}

local Headers: table = {
  ["ReForged-User-Identifier"] = "Vicious",
  ["ReForged-Fingerprint"] = "Vicious",
  ["User-Agent"] = "ReForged/0.0.5"
}

Misc:define("saveinstance", function(Options: table)
  Misc:checktype(1, Options, "table")
  local Place: string = Roblox.serializePlace(Internal.DataModel)
  
  FS.writefile(tostring(Default.DataModel.PlaceId) .. ".rbxl", Place)
end)

Misc:define("setclipboard", "toclipboard", "setrbxclipboard", function(Text: string)
  Misc:checktype(1, Text, "string")
  LastSaved = Text
end)

Misc:define("getclipboard", function(): string
  return LastSaved :: string
end)

Misc:define("queueonteleport", "queue_on_teleport", function(Text: string)
  Misc:checktype(1, Text, "string")
end)

Misc:define("identifyexecutor", "getexecutorname", function(): (string, string)
  return "ReForge", "0.0.5-stable"
end)

Misc:define("request", "http_request", function(Options: table): table
  Misc:checktype(1, Options, "table")
  Misc:checktype(2, Options.Url, "string")
  Misc:checktype(3, Options.Method, "string")
  
  local Scheme: table = Url.parse(Options.Url).scheme
  local Headers: table = table.clone(Headers)
  
  if Scheme ~= "http" and Scheme ~= "https" then
    error("Invalid scheme! expected ('http' or 'https')", 2)
  end
  
  assert(AllowedMethods[Options.Method], "Invalid method! expected ('GET' or 'HEAD' or 'POST' or 'PUT' or 'DELETE' or 'OPTIONS' or 'PATCH')")
  
  local Body = Options.Body
  if Body and type(Body) == "table" then
    Body = Serde.encode("json", Body)
  end
  
  Misc:checktype(4, Body, "string", "table", "nil")
  
  if Options.Headers then
    Misc:checktype(5, Options.Headers, "table")
    
    for Key: string, Value: string in pairs(Options.Headers) do
      if Headers[Key] == nil then
        Headers[Key] = Value
      end
    end
  end
  
  if Options.Cookies then
    Misc:checktype(6, Options.Cookies, "table")
  end
  
  local Status: bool, Result: table? = pcall(Net.request, {
    url = Options.Url,
    method = Options.Method,
    body = Body,
    headers = Headers
  })

  assert(Status, "Failed to fetch (request)")
  
  local Response: table = {
    Success = Result.ok,
    Body = Result.body,
    StatusCode = Result.statusCode,
    StatusMessage = Result.statusMessage,
    Headers = Result.headers
  }
  
  return table.clone(Response) :: table
end)

Http:define("request", function(Options: table): table
  Http:checktype(1, Options, "table")
  Http:checktype(2, Options.Url, "string")
  Http:checktype(3, Options.Method, "string")
  
  local Scheme: table = Url.parse(Options.Url).scheme
  local Headers: table = table.clone(Headers)
  
  if Scheme ~= "http" and Scheme ~= "https" then
    error("Invalid scheme! expected ('http' or 'https')", 2)
  end
  
  assert(AllowedMethods[Options.Method], "Invalid method! expected ('GET' or 'HEAD' or 'POST' or 'PUT' or 'DELETE' or 'OPTIONS' or 'PATCH')")
  
  local Body = Options.Body
  if Body and type(Body) == "table" then
    Body = Serde.encode("json", Body)
  end
  
  Http:checktype(4, Body, "string", "table", "nil")
  
  if Options.Headers then
    Http:checktype(5, Options.Headers, "table")
    
    for Key: string, Value: string in pairs(Options.Headers) do
      if Headers[Key] == nil then
        Headers[Key] = Value
      end
    end
  end
  
  if Options.Cookies then
    Http:checktype(6, Options.Cookies, "table")
  end
  
  local Status: bool, Result: table? = pcall(Net.request, {
    url = Options.Url,
    method = Options.Method,
    body = Body,
    headers = Headers
  })

  assert(Status, "Failed to fetch (request)")
  
  local Response: table = {
    Success = Result.ok,
    Body = Result.body,
    StatusCode = Result.statusCode,
    StatusMessage = Result.statusMessage,
    Headers = Result.headers
  }
  
  return table.clone(Response) :: table
end)

Misc:define("isrbxactive", "isgameactive", function(): string
  return true
end)

return Misc:export() :: table