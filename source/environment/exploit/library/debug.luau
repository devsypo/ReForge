local Internal: table = require("@env/internal")
local Manager: table = require("@env/manager")
local Debug: table = Manager.create("debug")

local Private: table = Internal.Private
local CallStack: table = Internal.CallStack
local CloneMap: table = Internal.CloneMap
local Script: table = Internal.Script
local FuncNames: table = Internal.FuncNames

local Info; Info = Debug:define("info", function(...): table
  local Arguments: table = {...}
  local Input: any = Arguments[1]
  
  Debug:checktype(1, Input, "function", "number", "thread")
  local Options: string?, Level: number?, Thread: thread?
  local IsA: string = typeof(Input)
  
  if IsA == "function" or IsA == "number" then
    Options = Arguments[2]
    Debug:checktype(2, Options, "string")
  elseif IsA == "thread" then
    Level, Options = Arguments[2], Arguments[3]
    Debug:checktype(3, Options, "string")
    Debug:checktype(2, Level, "number")
  else
    error("Invalid Input", 2)
  end
  
  local Results: table = {}
  
  if IsA == "function" then
    local LocalFunc = CloneMap[Input] or Input
    local IsC: table = Private.Iscclosure(LocalFunc)
    
    if IsC then
      local Name: string = FuncNames[LocalFunc] or debug.info(LocalFunc, "n")
      Results.Source = "[C]"
      Results.Line = -1
      Results.Name = Name
      Results.ParamCount = 0
      Results.Variadic = true
    else
      local Line, Count, Variadic = debug.info(LocalFunc, "la")
      local Name: string = FuncNames[LocalFunc] or debug.info(LocalFunc, "n")
      Results.Source = '[string "ReForged"]'
      Results.Line = Line
      Results.Name = Name
      Results.ParamCount = Count
      Results.Variadic = Variadic
    end
    
    Results.Object = Input
  end

  if IsA == "number" then
    local Frame: table = CallStack.Stack[Input]
    local Object: any? = Frame and Frame.Object
    local Org: any = Object
    
    local LocalFunc = CloneMap[Object] or Object
    Results.Object = Org
    
    if Input == 0 then
      Results.Source = "[C]"
      Results.Line = -1
      Results.Name = "info"
      Results.ParamCount = 0
      Results.Variadic = true
    elseif LocalFunc then
      local IsC: boolean = Private.Iscclosure(LocalFunc)
      
      if IsC then
        local Name: string = FuncNames[LocalFunc] or debug.info(LocalFunc, "n")
        
        Results.Source = "[C]"
        Results.Line = -1
        Results.Name = Name
        Results.ParamCount = 0
        Results.Variadic = true
      else
        local Line, Count, Variadic = debug.info(LocalFunc, "la")
        local Name: string = FuncNames[LocalFunc] or debug.info(LocalFunc, "n")
        
        Results.Source = '[string "ReForged"]'
        Results.Line = Line
        Results.Name = Name
        Results.ParamCount = Count
        Results.Variadic = Variadic
      end
    end
  end
  
  if IsA == "thread" then
    local StackLevel: number?
    
    for i = 1, 198 do
      local Status, Source = pcall(debug.info, Input, Level + i, "slnfa")
      if Status and Source == '[string "luau.load(...)"]' then
        StackLevel = Level + i - 1
        break
      end
    end
    
    if StackLevel then
      local Line, Object, Count, Variadic = debug.info(StackLevel, "lfa")
      local Org: any = Object
      Object = CloneMap[Object] or Object
      
      local Name: string = FuncNames[Object] or debug.info(Object, "n")
      
      Results.Source = '[string "ReForged"]'
      Results.Line = Line
      Results.Name = Name
      Results.Object = Org
      Results.ParamCount = Count
      Results.Variadic = Variadic
    end
    
    if Input == 0 then
      Results.Source = "[C]"
      Results.Line = -1
      Results.Name = "info"
      Results.Object = Input
      Results.ParamCount = 0
      Results.Variadic = true
    end
  end
  
  local Out: table = {}
  for i = 1, #Options do
    local Option = Options:sub(i,i)
    
    if Option == "s" then
      table.insert(Out, Results.Source)
    elseif Option == "l" then
      table.insert(Out, Results.Line)
    elseif Option == "n" then
      table.insert(Out, Results.Name)
    elseif Option == "f" then
      table.insert(Out, Results.Object or Input)
    elseif Option == "a" then
      table.insert(Out, Results.ParamCount)
      table.insert(Out, Results.Variadic)
    end
  end
  
  return unpack(Out)
end)

local GetInfo; GetInfo = Debug:define("getinfo", function(...): table
  local Arguments: table = {...}
  local Input: any = Arguments[1]
  
  Debug:checktype(1, Input, "function", "number")
  local IsA: string = typeof(Input)
  
  if IsA == "function" then
    local LocalFunc = CloneMap[Input] or Input
    local IsC: table = Private.Iscclosure(LocalFunc)
    
    if IsC then
      local Line, Name, Count, Variadic = Info(LocalFunc, "lna")
      return {
        source = "[C]",
        short_src = "",
        func = Input,
        what = "C",
        name = Name,
        nups = 0,
        numparams = Count,
        currentline = -1,
        is_vararg = (Variadic and 1) or 0
      }
    else
      local Frame: table = Script.Functions[LocalFunc]
      local UpvalueCount: number = (Frame and #Frame.Upvalues) or 0
      local Line, Name, Count, Variadic = Info(LocalFunc, "lna")
      
      return {
        source = '[string "ReForged"]',
        short_src = "ReForged",
        func = Input,
        what = "Lua",
        name = Name,
        nups = UpvalueCount,
        numparams = Count,
        currentline = Line,
        is_vararg = (Variadic and 1) or 0
      }
    end
  end
  
  if IsA == "number" then
    local Frame: table = CallStack.Stack[Input]
    local Object: any? = Frame and Frame.Object
    local Org: any = Object
    
    local LocalFunc = CloneMap[Object] or Object
    local IsC: table = Private.Iscclosure(LocalFunc)
    
    if IsC then
      local Line, Name, Count, Variadic = Info(LocalFunc, "lna")
      return {
        source = "[C]",
        short_src = "",
        func = Input,
        what = "C",
        name = Org,
        nups = 0,
        numparams = Count,
        currentline = -1,
        is_vararg = (Variadic and 1) or 0
      }
    else
      local Frame: table = Script.Functions[LocalFunc]
      local UpvalueCount: number = (Frame and #Frame.Upvalues) or 0
      local Line, Name, Count, Variadic = Info(LocalFunc, "lna")
      
      return {
        source = '[string "ReForged"]',
        short_src = "ReForged",
        func = Org,
        what = "Lua",
        name = Name,
        nups = UpvalueCount,
        numparams = Count,
        currentline = Line,
        is_vararg = (Variadic and 1) or 0
      }
    end
  end
  
  error("failed to inspect function", 2)
end)

Debug:define("getupvalue", function(...): any
  local Arguments: table = {...}
  local Input: any = Arguments[1]
  local Index: number = Arguments[2]
  
  Debug:checktype(1, Input, "function", "number")
  Debug:checktype(2, Index, "number")
  local IsA: string = typeof(Input)
  
  if IsA == "function" then
    local IsL: table = Private.Islclosure(Input)
    
    local Frame = Script.Functions[Input]
    if Frame and IsL then
      return Frame.Upvalues[Index]
    elseif not IsL then
      error("Cannot inspect C closure!", 2)
    end
  end
  
  if IsA == "number" then
    local Frame: table = CallStack.Stack[Input]
    local Object: any? = Frame and Frame.Object
    
    if Input == 0 then
      return nil
    elseif Object then
      local IsL: boolean = Private.Islclosure(Object)
      
      local Frame = Script.Functions[Object]
      if Frame and IsL then
        return Frame.Upvalues[Index]
      elseif not IsL then
        error("Cannot inspect C closure!", 2)
      end
    end
  end

  return nil
end)

Debug:define("getupvalues", function(...): any
  local Arguments: table = {...}
  local Input: any = Arguments[1]
  
  Debug:checktype(1, Input, "function", "number")
  local IsA: string = typeof(Input)
  
  if IsA == "function" then
    local IsL: table = Private.Islclosure(Input)
    
    local Frame = Script.Functions[Input]
    if Frame and IsL then
      return Frame.Upvalues
    elseif not IsL then
      error("Cannot inspect C closure!", 2)
    end
  end
  
  if IsA == "number" then
    local Frame: table = CallStack.Stack[Input]
    local Object: any? = Frame and Frame.Object
    
    if Input == 0 then
      return nil
    elseif Object then
      local IsL: boolean = Private.Islclosure(Object)
      
      local Frame = Script.Functions[Object]
      if Frame and IsL then
        return Frame.Upvalues
      elseif not IsL then
        error("Cannot inspect C closure!", 2)
      end
    end
  end
  
  return nil
end)

Debug:define("traceback", function(Message: any?, Level: number?)
  local MessageType = typeof(Message)

  if MessageType == "number" then
    Level = Message
    Message = nil
  end
  
  if Message and MessageType ~= "number" then
    Debug:checktype(1, Message, "string")
  end

  Level = (Level or 1)
  local Lines: table = {}
  
  if Message ~= nil then
    table.insert(Lines, tostring(Message))
  end

  local Top = #CallStack
  for i = Top - Level + 1, 1, -1 do
    local Frame = CallStack[i]
    if not Frame then
      continue
    end
    
    local obj = Frame.Object
    local Name = Frame.Name
    local Line = Frame.Metadata.Line
    
    table.insert(Lines, string.format('[string "ReForged"]:%d function %s', Line, Name))
  end

  return table.concat(Lines, "\n")
end)

Debug:define("setname", function(Input: any, New: string)
  Debug:checktype(1, Input, "function")
  Debug:checktype(2, New, "string")
  
  FuncNames[Input] = New
end)

return Debug:export() :: table