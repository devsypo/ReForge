local Aes: table = require("@dependency/aes")
local Base64: table = require("@dependency/base64")
local Manager: table = require("@env/manager")
local Serde: table = require("@lune/serde")
local Crypt: table = Manager.create("crypt")

local Encode = Base64.encode
local Decode = Base64.decode

local Base64: table = Crypt:namespace("base64")
local Hex: table = Crypt:namespace("hex")
local Lz4: table = Crypt:namespace("lz4")
local Random: table = Crypt:namespace("random")
local Rsa: table = Crypt:namespace("rsa") --https://web.archive.org/web/20250427125747/https://docs.zenith.win/API%20Reference/Crypt/RSA/
local Url: table = Crypt:namespace("url")

local SupportedHash: table = {
  md5 = true,
  sha1 = true,
  sha224 = true,
  sha256 = true,
  sha384 = true,
  sha512 = true,
  ["sha3-224"] = true,
  ["sha3-256"] = true,
  ["sha3-384"] = true,
  ["sha3-512"] = true,
  blake3 = true
}

local SupportedAES: table = {
  ECB = 1,
  CBC = 2,
  OFB = 3,
  CTR = 4,
  CFB = 4,
}

Base64:define("encode", function(Text: string): string
  Crypt:checktype(1, Text, "string")
  
  return Encode(Text) :: string
end)

Base64:define("decode", function(Text: string): string
  Crypt:checktype(1, Text, "string")
  
  return Decode(Text) :: string
end)

Hex:define("encode", function(Text: string): string
  Hex:checktype(1, Text, "string")
  local Length: number = #Text
  local Out: table = table.create(Length)
  
  for i = 1, Length do
    Out[i] = string.format("%02X", string.Byte(Text, i))
  end
  
  return table.concat(Out) :: string
end)

Hex:define("decode", function(Text: string): string
  Hex:checktype(1, Text, "string")
  local Length: number = #Text
  
  assert(Length % 2 == 0, "invalid argument #1 to 'crypt.hex.decode' (even hex string expected, got uneven)")
  local Out: table = table.create(Length / 2)

  for i = 1, Length, 2 do
    local Byte: number = tonumber(Text:sub(i, i+1), 16)
    assert(Byte, "invalid argument #1 to 'crypt.hex.decode' (invalid hex character at position " .. i .. ")")
    
    Out[math.floor((i + 1) / 2)] = string.char(Byte)
  end

  return table.concat(Out) :: string
end)

Lz4:define("compress", function(Text: string): string
  Lz4:checktype(1, Text, "string")
  
  return Serde.compress("lz4", Text)
end)

Lz4:define("decompress", function(Text: string): string
  Lz4:checktype(1, Text, "string")
  
  return Serde.decompress("lz4", Text)
end)

Random:define("string", function(Length: number): string
  Random:checktype(1, Length, "number")
  Length = Length or 32
  assert(Length >= 1 and Length <= 1024, "crypt.random.string: expected argument #1 to be greater than 0 and less than 1024, got " .. Length)
  
  local Charset = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  local Out = table.create(Length)

  local Bytes = table.create(62)
  for i = 1, 62 do
    Bytes[i] = Charset:sub(i, i)
  end

  for i = 1, Length do
    Out[i] = Bytes[math.random(1, 62)]
  end

  return table.concat(Out) :: string
end)

Random:define("number", function(Length: number): number
  Random:checktype(1, Length, "number")
  Length = Length or 18
  assert(Length >= 1 and Length <= 18, "crypt.random.number: expected argument #1 to be between 1 and 18, got " .. Length)

  local Result = 0
  for _ = 1, Length do
    Result = Result * 10 + math.random(0, 9)
  end

  return Result :: number
end)

Rsa:define("generate_key_pair", function(Bits: number): (string, string)
  Rsa:checktype(1, Bits, "string")
  
  error("cLUNE", 2)
end)

Rsa:define("encrypt", function(Data: string, PublicKey: string): string
  Rsa:checktype(1, Data, "string")
  Rsa:checktype(2, PublicKey, "string")
  
  error("cLUNE", 2)
end)

Rsa:define("decrypt", function(Data: string, PrivateKey: string): string
  Rsa:checktype(1, Data, "string")
  Rsa:checktype(2, PrivateKey, "string")
  
  error("cLUNE", 2)
end)

Rsa:define("sign", function(Data: string, PrivateKey: string): string
  Rsa:checktype(1, Data, "string")
  Rsa:checktype(2, PrivateKey, "string")
  
  error("cLUNE", 2)
end)

Rsa:define("verify", function(Data: string, Signature: string, PublicKey: string): string
  Rsa:checktype(1, Data, "string")
  Rsa:checktype(2, Signature, "string")
  Rsa:checktype(3, PublicKey, "string")
  
  error("cLUNE", 2)
end)

Url:define("encode", function(Url: string): string
  Url:checktype(1, Url, "string")
  
  local Length = #Url
  local Out: table = table.create(Length)
  
  for i = 1, Length do
    local Character: string = Url:sub(i, i)
    local Byte: string = string.byte(Character)
    
    if Character:match("[%w%-._~]")then
      Out[i] = Character
      continue
    end
    
    Out[i] = string.format("%%%02X", Byte)
  end

  return table.concat(Out) :: string 
end)

Url:define("decode", function(Url: string): string
  Url:checktype(1, Url, "string")
  
  local Length: number = #Url
  local Out: table = table.create(Length)
  
  local i: number = 1
  while i <= Length do
    local Character = Url:sub(i, i)
    if Character == "%" then
      local Hex = Url:sub(i + 1, i + 2)
      assert(Hex:match("%x%x"), "invalid argument #1 to 'crypt.url.decode' (invalid percent-encoding at position " .. i .. ")")
      
      table.insert(Out, string.char(tonumber(Hex, 16)))
      i = i + 3
      
      continue
    end
    
    table.insert(Out, Character)
    i = i + 1
  end

  return table.concat(Out) :: string
end)

Crypt:define("base64encode", "base64_encode", function(Text: string): string
  Crypt:checktype(1, Text, "string")
  
  return Encode(Text) :: string
end)

Crypt:define("base64decode", "base64_decode", function(Text: string): string
  Crypt:checktype(1, Text, "string")
  
  return Decode(Text) :: string
end)

Crypt:define("random", function(Length: number): string
  Crypt:checktype(1, Length, "number")
  Length = Length or 32
  assert(Length >= 1 and Length <= 1024, "crypt.random: expected argument #1 to be greater than 0 and less than 1024, got " .. Length)
  
  local Charset = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  local Out = table.create(Length)

  local Bytes = table.create(62)
  for i = 1, 62 do
    Bytes[i] = Charset:sub(i, i)
  end

  for i = 1, Length do
    Out[i] = Bytes[math.random(1, 62)]
  end

  return table.concat(Out) :: string
end)

Crypt:define("generatebytes", function(Length: number): string
  Crypt:checktype(1, Length, "number")
  
  local Bytes: table = table.create(Length)
  for i = 1, Length do
    Bytes[i] = string.char(math.random(1, 255))
  end
  
  return Encode(table.concat(Bytes)) :: string
end)

Crypt:define("generatekey", function(): string
  local Bytes: table = table.create(32)
  
  for i = 1, 32 do
    Bytes[i] = string.char(math.random(0, 255))
  end
  
  return Encode(table.concat(Bytes)) :: string
end)

Crypt:define("derive", function(Value: string, Length: number): string
  Crypt:checktype(1, Value, "string")
  Crypt:checktype(2, Length, "number")

  local ChunkLength = #Serde.hash("sha256", Value .. "1")
  local NumIterations = math.ceil(Length / ChunkLength)
  
  local Out: { string } = table.create(NumIterations)
  local Counter: number = 1
  local TotalLen: number = 0

  while TotalLen < Length do
    local Chunk: string = Serde.hash("sha256", Value .. Counter)
    Out[#Out + 1] = Chunk
    TotalLen += #Chunk
    Counter += 1
  end

  local Result: string = table.concat(Out)
  
  return Result:sub(1, Length) :: string
end)

Crypt:define("hash", function(Data: string, Algorithm: string): string
  Crypt:checktype(1, Data, "string")
  Algorithm = Algorithm or "sha384"
  Crypt:checktype(2, Algorithm, "string")
  
  assert(SupportedHash[Algorithm], "invalid argument #1 to 'crypt.hash' (valid algorithm expected, got '" .. Algorithm .. "')")
  
  return Serde.hash(Algorithm, Data) :: string
end)

Crypt:define("hmac", function(Key: string, Data: string, Algorithm: string): string
  Crypt:checktype(1, Key, "string")
  Crypt:checktype(2, Data, "string")
  Crypt:checktype(3, Algorithm, "string")
  
  assert(SupportedHash[Algorithm], "invalid argument #3 to 'crypt.hmac' (valid algorithm expected, got '" .. Algorithm .. "')")
  
  return Serde.hmac(Algorithm, Data, Key) :: string
end)

Crypt:define("encrypt", function(Data: string, Key: string, Iv: string?, Mode: string?): (string, string)
  Crypt:checktype(1, Data, "string")
  Crypt:checktype(2, Key, "string")
  Mode = string.upper(Mode or "CBC")
  
  if Iv ~= nil then
    Crypt:checktype(3, Iv, "string")
  end
  
  assert(SupportedAES[Mode], "invalid argument #4 to 'crypt.encrypt' (valid mode expected, got '" .. Mode .. "')")
  
  local KeyBytes: string = Decode(Key)
  assert(#KeyBytes == 32, "invalid argument #2 to 'crypt.encrypt' (256-bit base64 key expected, got " .. #KeyBytes .. " bytes)")
  
  local IvBytes: table? = nil
  local IvString: string = ""
  
  if Iv == nil and Mode ~= "ECB" then
    IvString = string.rep(string.char(0), 16)
    IvBytes = {}
    for i = 1, 16 do
      IvBytes[i] = 0
    end
  elseif Iv ~= nil then
    IvString = Decode(Iv)
    IvBytes = {}
    for i = 1, 16 do
      IvBytes[i] = string.byte(IvString, i)
    end
  end
  
  local Status: boolean, EncryptedData: string = pcall(Aes.encrypt, KeyBytes, Data, 32, SupportedAES[Mode], IvBytes)
  assert(Status, "crypt.encrypt: failed to encrypt! error occured while processing")
  
  local EncodedData: string = Encode(EncryptedData)
  local EncodedIv: string = Encode(IvString)
  
  return EncodedData :: string, EncodedIv :: string
end)

Crypt:define("decrypt", function(Data: string, Key: string, Iv: string?, Mode: string): string
  Crypt:checktype(1, Data, "string")
  Crypt:checktype(2, Key, "string")
  
  if Iv ~= nil then
    Crypt:checktype(3, Iv, "string")
  end
  
  Crypt:checktype(4, Mode, "string")
  Mode = string.upper(Mode)
  
  assert(SupportedAES[Mode], "invalid argument #4 to 'crypt.decrypt' (valid mode expected, got '" .. Mode .. "')")
  
  local KeyBytes: string = Decode(Key)
  assert(#KeyBytes == 32, "invalid argument #2 to 'crypt.decrypt' (256-bit base64 key expected, got " .. #KeyBytes .. " bytes)")
  
  local IvBytes: table? = nil
  if Iv ~= nil then
    local IvString: string = Decode(Iv)
    IvBytes = {}
    for i = 1, 16 do
      IvBytes[i] = string.byte(IvString, i)
    end
  end
  
  local EncryptedString: string = Decode(Data)
  
  local Status: boolean, DecryptedData: string = pcall(Aes.decrypt, KeyBytes, EncryptedString, 32, SupportedAES[Mode], IvBytes)
  assert(Status, "crypt.decrypt: failed to decrypt! error occured while processing")
  
  return DecryptedData :: string
end)

return Crypt:export() :: table